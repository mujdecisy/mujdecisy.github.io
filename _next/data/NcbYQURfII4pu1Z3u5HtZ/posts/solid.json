{"pageProps":{"post":{"title":"SOLID Prensipleri","date":"2024-05-10","summary":"SOLID (Single Responsibility, Open-Close, Liskov Substitution, Interface Segregation, Dependency Inversion) Prensipleri nedir? SOLID Prensiplerinin amacı ve kullanım senaryoları","body":{"raw":"\n# SOLID Prensipleri\n\nSOLID prensipleri, yazılım geliştirme sürecinde daha temiz, esnek ve sürdürülebilir kod yazmak için kullanılan beş temel prensiptir. Bu prensipler, yazılım tasarımında karmaşıklığı azaltmak, kodun bakımını kolaylaştırmak ve kodun daha iyi anlaşılmasını sağlamak amacıyla geliştirilmiştir.\n\n## *Single Responsibility Principle*\n**Tek Sorumluluk Prensibi.**\nBir sınıfın sadece bir sorumluluğu olmalıdır. Her sınıfın tek bir işlevi veya sorumluluğu olmalıdır. Böylece, değişikliklerin etkileri sınırlı olur ve kod daha anlaşılabilir hale gelir.\n\n## *Open-Closed Principle*\n**Açık Kapalı Prensibi.**\nBir sınıf, mevcut davranışları değiştirmeden yeni davranışlar ekleyebilmelidir. Yani bir sınıf, genişletmeye açık (open for extension) ancak değişikliğe kapalı (closed for modification) olmalıdır. Bu prensip, kodun daha az kırılgan olmasını ve daha kolay genişletilebilir olmasını sağlar.\n\n## *Liskov Substitution Principle*\n**Liskov Yerine Geçme Prensibi.**\nÜst sınıflar, alt sınıflar tarafından sorunsuz bir şekilde yerine geçilebilir olmalıdır. Yani, bir üst sınıfın yerine alt sınıf geçtiğinde, hiçbir şey bozulmamalı veya hatalara yol açmamalıdır. Bu prensip, sınıf hiyerarşilerinin doğru bir şekilde yapılandırılmasını ve polimorfizmin etkin bir şekilde kullanılmasını sağlar.\n\n## *Interface Segregation Principle*\n**Arayüz Ayrımı Prensibi.**\nİstemciye gereksinim duymadığı özellikleri dayatmamak amacıyla, mümkün olduğunca özelleştirilmiş arayüzler kullanılmalıdır. Yani, bir sınıf, kullanılmayacak olan metotları içeren geniş arayüzler yerine daha küçük ve özelleştirilmiş arayüzler kullanmalıdır. Bu prensip, bağımlılıkları azaltır ve sınıflar arasındaki bağlantıları gevşetir.\n\n## *Dependency Inversion Principle*\n**Bağımlılığı Tersine Çevirme Prensibi.**\nÜst seviye modüller, alt seviye modüllere doğrudan bağımlı olmamalıdır. İstikrarlı ve yeniden kullanılabilir bir kod için, bağımlılıklar soyutlamalara (interface veya abstract class) dayandırılmalıdır. Bu prensip, birim testlerin daha kolay yapılabilmesini sağlar ve bağımlılıkları yönetmeyi kolaylaştırır.","code":"var Component=(()=>{var c=Object.create;var r=Object.defineProperty;var k=Object.getOwnPropertyDescriptor;var u=Object.getOwnPropertyNames;var y=Object.getPrototypeOf,p=Object.prototype.hasOwnProperty;var h=(i,e)=>()=>(e||i((e={exports:{}}).exports,e),e.exports),b=(i,e)=>{for(var l in e)r(i,l,{get:e[l],enumerable:!0})},t=(i,e,l,s)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let a of u(e))!p.call(i,a)&&a!==l&&r(i,a,{get:()=>e[a],enumerable:!(s=k(e,a))||s.enumerable});return i};var g=(i,e,l)=>(l=i!=null?c(y(i)):{},t(e||!i||!i.__esModule?r(l,\"default\",{value:i,enumerable:!0}):l,i)),v=i=>t(r({},\"__esModule\",{value:!0}),i);var d=h((D,m)=>{m.exports=_jsx_runtime});var S={};b(S,{default:()=>P,frontmatter:()=>f});var n=g(d()),f={title:\"SOLID Prensipleri\",date:new Date(17152992e5),summary:\"SOLID (Single Responsibility, Open-Close, Liskov Substitution, Interface Segregation, Dependency Inversion) Prensipleri nedir? SOLID Prensiplerinin amac\\u0131 ve kullan\\u0131m senaryolar\\u0131\"};function o(i){let e=Object.assign({h1:\"h1\",p:\"p\",h2:\"h2\",em:\"em\",strong:\"strong\"},i.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.h1,{children:\"SOLID Prensipleri\"}),`\n`,(0,n.jsx)(e.p,{children:\"SOLID prensipleri, yaz\\u0131l\\u0131m geli\\u015Ftirme s\\xFCrecinde daha temiz, esnek ve s\\xFCrd\\xFCr\\xFClebilir kod yazmak i\\xE7in kullan\\u0131lan be\\u015F temel prensiptir. Bu prensipler, yaz\\u0131l\\u0131m tasar\\u0131m\\u0131nda karma\\u015F\\u0131kl\\u0131\\u011F\\u0131 azaltmak, kodun bak\\u0131m\\u0131n\\u0131 kolayla\\u015Ft\\u0131rmak ve kodun daha iyi anla\\u015F\\u0131lmas\\u0131n\\u0131 sa\\u011Flamak amac\\u0131yla geli\\u015Ftirilmi\\u015Ftir.\"}),`\n`,(0,n.jsx)(e.h2,{children:(0,n.jsx)(e.em,{children:\"Single Responsibility Principle\"})}),`\n`,(0,n.jsxs)(e.p,{children:[(0,n.jsx)(e.strong,{children:\"Tek Sorumluluk Prensibi.\"}),`\nBir s\\u0131n\\u0131f\\u0131n sadece bir sorumlulu\\u011Fu olmal\\u0131d\\u0131r. Her s\\u0131n\\u0131f\\u0131n tek bir i\\u015Flevi veya sorumlulu\\u011Fu olmal\\u0131d\\u0131r. B\\xF6ylece, de\\u011Fi\\u015Fikliklerin etkileri s\\u0131n\\u0131rl\\u0131 olur ve kod daha anla\\u015F\\u0131labilir hale gelir.`]}),`\n`,(0,n.jsx)(e.h2,{children:(0,n.jsx)(e.em,{children:\"Open-Closed Principle\"})}),`\n`,(0,n.jsxs)(e.p,{children:[(0,n.jsx)(e.strong,{children:\"A\\xE7\\u0131k Kapal\\u0131 Prensibi.\"}),`\nBir s\\u0131n\\u0131f, mevcut davran\\u0131\\u015Flar\\u0131 de\\u011Fi\\u015Ftirmeden yeni davran\\u0131\\u015Flar ekleyebilmelidir. Yani bir s\\u0131n\\u0131f, geni\\u015Fletmeye a\\xE7\\u0131k (open for extension) ancak de\\u011Fi\\u015Fikli\\u011Fe kapal\\u0131 (closed for modification) olmal\\u0131d\\u0131r. Bu prensip, kodun daha az k\\u0131r\\u0131lgan olmas\\u0131n\\u0131 ve daha kolay geni\\u015Fletilebilir olmas\\u0131n\\u0131 sa\\u011Flar.`]}),`\n`,(0,n.jsx)(e.h2,{children:(0,n.jsx)(e.em,{children:\"Liskov Substitution Principle\"})}),`\n`,(0,n.jsxs)(e.p,{children:[(0,n.jsx)(e.strong,{children:\"Liskov Yerine Ge\\xE7me Prensibi.\"}),`\n\\xDCst s\\u0131n\\u0131flar, alt s\\u0131n\\u0131flar taraf\\u0131ndan sorunsuz bir \\u015Fekilde yerine ge\\xE7ilebilir olmal\\u0131d\\u0131r. Yani, bir \\xFCst s\\u0131n\\u0131f\\u0131n yerine alt s\\u0131n\\u0131f ge\\xE7ti\\u011Finde, hi\\xE7bir \\u015Fey bozulmamal\\u0131 veya hatalara yol a\\xE7mamal\\u0131d\\u0131r. Bu prensip, s\\u0131n\\u0131f hiyerar\\u015Filerinin do\\u011Fru bir \\u015Fekilde yap\\u0131land\\u0131r\\u0131lmas\\u0131n\\u0131 ve polimorfizmin etkin bir \\u015Fekilde kullan\\u0131lmas\\u0131n\\u0131 sa\\u011Flar.`]}),`\n`,(0,n.jsx)(e.h2,{children:(0,n.jsx)(e.em,{children:\"Interface Segregation Principle\"})}),`\n`,(0,n.jsxs)(e.p,{children:[(0,n.jsx)(e.strong,{children:\"Aray\\xFCz Ayr\\u0131m\\u0131 Prensibi.\"}),`\n\\u0130stemciye gereksinim duymad\\u0131\\u011F\\u0131 \\xF6zellikleri dayatmamak amac\\u0131yla, m\\xFCmk\\xFCn oldu\\u011Funca \\xF6zelle\\u015Ftirilmi\\u015F aray\\xFCzler kullan\\u0131lmal\\u0131d\\u0131r. Yani, bir s\\u0131n\\u0131f, kullan\\u0131lmayacak olan metotlar\\u0131 i\\xE7eren geni\\u015F aray\\xFCzler yerine daha k\\xFC\\xE7\\xFCk ve \\xF6zelle\\u015Ftirilmi\\u015F aray\\xFCzler kullanmal\\u0131d\\u0131r. Bu prensip, ba\\u011F\\u0131ml\\u0131l\\u0131klar\\u0131 azalt\\u0131r ve s\\u0131n\\u0131flar aras\\u0131ndaki ba\\u011Flant\\u0131lar\\u0131 gev\\u015Fetir.`]}),`\n`,(0,n.jsx)(e.h2,{children:(0,n.jsx)(e.em,{children:\"Dependency Inversion Principle\"})}),`\n`,(0,n.jsxs)(e.p,{children:[(0,n.jsx)(e.strong,{children:\"Ba\\u011F\\u0131ml\\u0131l\\u0131\\u011F\\u0131 Tersine \\xC7evirme Prensibi.\"}),`\n\\xDCst seviye mod\\xFCller, alt seviye mod\\xFCllere do\\u011Frudan ba\\u011F\\u0131ml\\u0131 olmamal\\u0131d\\u0131r. \\u0130stikrarl\\u0131 ve yeniden kullan\\u0131labilir bir kod i\\xE7in, ba\\u011F\\u0131ml\\u0131l\\u0131klar soyutlamalara (interface veya abstract class) dayand\\u0131r\\u0131lmal\\u0131d\\u0131r. Bu prensip, birim testlerin daha kolay yap\\u0131labilmesini sa\\u011Flar ve ba\\u011F\\u0131ml\\u0131l\\u0131klar\\u0131 y\\xF6netmeyi kolayla\\u015Ft\\u0131r\\u0131r.`]})]})}function z(i={}){let{wrapper:e}=i.components||{};return e?(0,n.jsx)(e,Object.assign({},i,{children:(0,n.jsx)(o,i)})):o(i)}var P=z;return v(S);})();\n;return Component;"},"_id":"solid.mdx","_raw":{"sourceFilePath":"solid.mdx","sourceFileName":"solid.mdx","sourceFileDir":".","contentType":"mdx","flattenedPath":"solid"},"type":"Post","url":"/posts/solid"}},"__N_SSG":true}