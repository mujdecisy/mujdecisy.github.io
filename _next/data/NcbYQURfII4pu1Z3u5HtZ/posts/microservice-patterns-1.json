{"pageProps":{"post":{"title":"Mikroservis Desenleri - 1","date":"2024-05-09","summary":"En çok kullanılan mikro servis desenleri ve kullanım amaçları.","body":{"raw":"\n# Mikroservis Desenleri\n\n{props.rdrImg(\n    \"/content-images/ms-patterns-1.png\",\n    \"\"\n)}\n\n## *API Gateway*\nAPI Gateway, bir mikro hizmet mimarisi içinde bir merkezi nokta olarak hareket eder ve istemcilerin tüm hizmetlerle etkileşim kurmak yerine tek bir API aracılığıyla iletişim kurmalarını sağlar. Örneğin, bir e-ticaret uygulamasında, müşterilerin satın alma işlemlerini gerçekleştirmek için ödeme, envanter, kargo vb. hizmetlere ihtiyaçları vardır. API Gateway, müşterilerin tüm bu hizmetlere tek bir API aracılığıyla erişmelerini ve satın alma işlemlerini tamamlamalarını sağlar.\n\n## *Service Registry*\nHizmet kaydı, tüm hizmetlerin (API'ler, veri tabanları vb.) adlarının ve adreslerinin tutulduğu bir merkezi kaynaktır. Örneğin, bir e-ticaret uygulamasında, ödeme hizmeti değişirse, hizmet kaydındaki ad ve adres bilgisi güncellenerek, diğer hizmetlerin ödeme hizmeti ile etkileşimini sürdürmesi sağlanır.\n\n## *Circuit Breaker*\nCircuit Breaker, hata toleransını artırmak için kullanılan bir tasarım desenidir. Örneğin, bir bankacılık uygulamasında, para transferi hizmeti için hata oluşursa Circuit Breaker devreye girerek, hizmeti geçici olarak durdurur ve müşteri verilerini korur.\n\nCircuit Breaker pattern, bir yazılım uygulamasının hata toleransını artırmak için kullanılan bir tasarım desenidir. Bu desen, bir hizmet çağrısı yaparken, olası hataların önüne geçmek ve sistemdeki diğer hizmetleri de etkilemeden hatalı hizmet çağrısını düzeltmek için kullanılır.\n\nBu desen, hizmet çağrılarından önce belirli bir süre boyunca hizmet sağlayıcısına yapılan çağrı sayısını takip eder. Eğer bir hizmet sağlayıcısı belirlenen sayıda çağrıda hata verirse, Circuit Breaker devreye girerek çağrıları engeller ve sistemdeki diğer hizmetlere etki etmemesini sağlar.\n\nCircuit Breaker, hata sayısını belirli bir seviyenin üzerine çıktığında, hizmet çağrılarını otomatik olarak reddeder ve bir belirteç döndürür. Bu belirteç, uygulamanın hata sayısını belirleyebilmesini sağlar ve hata durumunda sistemdeki diğer bileşenleri korur.\n\n### Circuit Breaker States\n\n* Closed (Kapalı): İlk durumda Circuit Breaker kapalıdır ve normal hizmet çağrılarına izin verir. Hizmet sağlayıcısına yapılan çağrılar hata vermez ve Circuit Breaker açılmaz.\n* Open (Açık): İkinci durumda Circuit Breaker açıktır ve hizmet çağrıları reddedilir. Bu durum, belirli bir süre boyunca hizmet sağlayıcısına yapılan çağrıların belirli bir oranda hata vermesi sonucu meydana gelir.\n* Half-Open (Yarı Açık): Üçüncü durumda Circuit Breaker yarı açıktır ve birkaç hizmet çağrısını izin verir. Bu durumda, Circuit Breaker, bir hizmet çağrısı yaparak hizmet sağlayıcısının tekrar çalışıp çalışmadığını kontrol eder. Eğer hizmet çağrısı başarılı olursa, Circuit Breaker tekrar kapalı duruma geçer ve normal hizmet çağrılarına izin verir. Ancak, hizmet çağrısı başarısız olursa, Circuit Breaker tekrar açık duruma geçer ve hizmet çağrıları reddedilir.\n\n## *Saga Pattern*\nBu pattern, bir işlem zinciri boyunca birden fazla mikroservis çağrısını yönetmek için kullanılır. Saga, bir işlemi birden fazla adımda gerçekleştiren bir işlem zinciri olarak düşünülebilir. Her adım, bir mikroservis çağrısını temsil eder ve hata toleransını sağlamak için geri alma (compensation) adımları eklenir. Örneğin, bir siparişin işlenmesi, bir müşteriye ödeme yapılması ve bir ürünün sevkiyatının yapılması gibi birçok adımdan oluşabilir.\n\n## *Event Sourcing Pattern*\nBu pattern, bir uygulamada meydana gelen tüm olayların bir kayıdında saklandığı bir yaklaşımdır. Bu olaylar, uygulamanın durumunu oluşturur ve her bir olay, uygulamanın geçmiş durumuna dayalı olarak bir sonraki durumu etkiler. Bu pattern, birçok işlemi ve veri güncellemesini kolaylaştırır ve hata ayıklama ve geri alma işlemlerini kolaylaştırır. Örneğin, bir banka uygulamasında, bir müşterinin hesap hareketleri kaydedilebilir ve bu bilgiler, müşterinin hesap geçmişi veya raporlama için kullanılabilir.\n\n## *Strangler Pattern*\nBu desen, mevcut bir uygulamanın veya sistemin sürdürülmesi veya yeniden geliştirilmesi gerektiğinde kullanılır. Temel amacı, mevcut sistemi yavaş yavaş terk ederek, yeni bir sistem veya uygulama inşa etmeyi ve eski sistem yerine kullanmayı hedefler.\n\n## *CQRS*\nCommand Query Responsibility Segregation bir yazılım mimarisi desenidir. Bu desen, bir uygulamanın komutlarını (veri yazma işlemleri) ve sorgularını (veri okuma işlemleri) farklı işlemler olarak ele alarak, farklı birimlerde işlemesi fikrine dayanır.\n\nGeleneksel bir uygulama mimarisinde, hem veri yazma hem de veri okuma işlemleri aynı veri modeli üzerinde gerçekleştirilir. Bu, uygulamanın performansını olumsuz yönde etkileyebilir ve karmaşık iş mantığını zorlaştırabilir.\n\nCQRS yaklaşımında, veri yazma işlemleri ve veri okuma işlemleri farklı birimlerde ele alınır. Veri yazma işlemleri, veri modelinde değişiklik yapmak yerine, komutlar aracılığıyla bir durum değişikliği gerçekleştirir. Veri okuma işlemleri ise, okuma işlemleri için optimize edilmiş ayrı bir veri modeli kullanır. Bu, uygulamanın performansını artırabilir ve daha kolay bakım yapılabilmesini sağlayabilir.\n\n","code":"var Component=(()=>{var k=Object.create;var l=Object.defineProperty;var h=Object.getOwnPropertyDescriptor;var y=Object.getOwnPropertyNames;var c=Object.getPrototypeOf,o=Object.prototype.hasOwnProperty;var b=(i,e)=>()=>(e||i((e={exports:{}}).exports,e),e.exports),v=(i,e)=>{for(var a in e)l(i,a,{get:e[a],enumerable:!0})},t=(i,e,a,m)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let n of y(e))!o.call(i,n)&&n!==a&&l(i,n,{get:()=>e[n],enumerable:!(m=h(e,n))||m.enumerable});return i};var g=(i,e,a)=>(a=i!=null?k(c(i)):{},t(e||!i||!i.__esModule?l(a,\"default\",{value:i,enumerable:!0}):a,i)),z=i=>t(l({},\"__esModule\",{value:!0}),i);var s=b((A,d)=>{d.exports=_jsx_runtime});var f={};v(f,{default:()=>C,frontmatter:()=>p});var r=g(s()),p={title:\"Mikroservis Desenleri - 1\",date:new Date(17152128e5),summary:\"En \\xE7ok kullan\\u0131lan mikro servis desenleri ve kullan\\u0131m ama\\xE7lar\\u0131.\"};function u(i){let e=Object.assign({h1:\"h1\",h2:\"h2\",em:\"em\",p:\"p\",h3:\"h3\",ul:\"ul\",li:\"li\"},i.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(e.h1,{children:\"Mikroservis Desenleri\"}),`\n`,i.rdrImg(\"/content-images/ms-patterns-1.png\",\"\"),`\n`,(0,r.jsx)(e.h2,{children:(0,r.jsx)(e.em,{children:\"API Gateway\"})}),`\n`,(0,r.jsx)(e.p,{children:\"API Gateway, bir mikro hizmet mimarisi i\\xE7inde bir merkezi nokta olarak hareket eder ve istemcilerin t\\xFCm hizmetlerle etkile\\u015Fim kurmak yerine tek bir API arac\\u0131l\\u0131\\u011F\\u0131yla ileti\\u015Fim kurmalar\\u0131n\\u0131 sa\\u011Flar. \\xD6rne\\u011Fin, bir e-ticaret uygulamas\\u0131nda, m\\xFC\\u015Fterilerin sat\\u0131n alma i\\u015Flemlerini ger\\xE7ekle\\u015Ftirmek i\\xE7in \\xF6deme, envanter, kargo vb. hizmetlere ihtiya\\xE7lar\\u0131 vard\\u0131r. API Gateway, m\\xFC\\u015Fterilerin t\\xFCm bu hizmetlere tek bir API arac\\u0131l\\u0131\\u011F\\u0131yla eri\\u015Fmelerini ve sat\\u0131n alma i\\u015Flemlerini tamamlamalar\\u0131n\\u0131 sa\\u011Flar.\"}),`\n`,(0,r.jsx)(e.h2,{children:(0,r.jsx)(e.em,{children:\"Service Registry\"})}),`\n`,(0,r.jsx)(e.p,{children:\"Hizmet kayd\\u0131, t\\xFCm hizmetlerin (API'ler, veri tabanlar\\u0131 vb.) adlar\\u0131n\\u0131n ve adreslerinin tutuldu\\u011Fu bir merkezi kaynakt\\u0131r. \\xD6rne\\u011Fin, bir e-ticaret uygulamas\\u0131nda, \\xF6deme hizmeti de\\u011Fi\\u015Firse, hizmet kayd\\u0131ndaki ad ve adres bilgisi g\\xFCncellenerek, di\\u011Fer hizmetlerin \\xF6deme hizmeti ile etkile\\u015Fimini s\\xFCrd\\xFCrmesi sa\\u011Flan\\u0131r.\"}),`\n`,(0,r.jsx)(e.h2,{children:(0,r.jsx)(e.em,{children:\"Circuit Breaker\"})}),`\n`,(0,r.jsx)(e.p,{children:\"Circuit Breaker, hata tolerans\\u0131n\\u0131 art\\u0131rmak i\\xE7in kullan\\u0131lan bir tasar\\u0131m desenidir. \\xD6rne\\u011Fin, bir bankac\\u0131l\\u0131k uygulamas\\u0131nda, para transferi hizmeti i\\xE7in hata olu\\u015Fursa Circuit Breaker devreye girerek, hizmeti ge\\xE7ici olarak durdurur ve m\\xFC\\u015Fteri verilerini korur.\"}),`\n`,(0,r.jsx)(e.p,{children:\"Circuit Breaker pattern, bir yaz\\u0131l\\u0131m uygulamas\\u0131n\\u0131n hata tolerans\\u0131n\\u0131 art\\u0131rmak i\\xE7in kullan\\u0131lan bir tasar\\u0131m desenidir. Bu desen, bir hizmet \\xE7a\\u011Fr\\u0131s\\u0131 yaparken, olas\\u0131 hatalar\\u0131n \\xF6n\\xFCne ge\\xE7mek ve sistemdeki di\\u011Fer hizmetleri de etkilemeden hatal\\u0131 hizmet \\xE7a\\u011Fr\\u0131s\\u0131n\\u0131 d\\xFCzeltmek i\\xE7in kullan\\u0131l\\u0131r.\"}),`\n`,(0,r.jsx)(e.p,{children:\"Bu desen, hizmet \\xE7a\\u011Fr\\u0131lar\\u0131ndan \\xF6nce belirli bir s\\xFCre boyunca hizmet sa\\u011Flay\\u0131c\\u0131s\\u0131na yap\\u0131lan \\xE7a\\u011Fr\\u0131 say\\u0131s\\u0131n\\u0131 takip eder. E\\u011Fer bir hizmet sa\\u011Flay\\u0131c\\u0131s\\u0131 belirlenen say\\u0131da \\xE7a\\u011Fr\\u0131da hata verirse, Circuit Breaker devreye girerek \\xE7a\\u011Fr\\u0131lar\\u0131 engeller ve sistemdeki di\\u011Fer hizmetlere etki etmemesini sa\\u011Flar.\"}),`\n`,(0,r.jsx)(e.p,{children:\"Circuit Breaker, hata say\\u0131s\\u0131n\\u0131 belirli bir seviyenin \\xFCzerine \\xE7\\u0131kt\\u0131\\u011F\\u0131nda, hizmet \\xE7a\\u011Fr\\u0131lar\\u0131n\\u0131 otomatik olarak reddeder ve bir belirte\\xE7 d\\xF6nd\\xFCr\\xFCr. Bu belirte\\xE7, uygulaman\\u0131n hata say\\u0131s\\u0131n\\u0131 belirleyebilmesini sa\\u011Flar ve hata durumunda sistemdeki di\\u011Fer bile\\u015Fenleri korur.\"}),`\n`,(0,r.jsx)(e.h3,{children:\"Circuit Breaker States\"}),`\n`,(0,r.jsxs)(e.ul,{children:[`\n`,(0,r.jsx)(e.li,{children:\"Closed (Kapal\\u0131): \\u0130lk durumda Circuit Breaker kapal\\u0131d\\u0131r ve normal hizmet \\xE7a\\u011Fr\\u0131lar\\u0131na izin verir. Hizmet sa\\u011Flay\\u0131c\\u0131s\\u0131na yap\\u0131lan \\xE7a\\u011Fr\\u0131lar hata vermez ve Circuit Breaker a\\xE7\\u0131lmaz.\"}),`\n`,(0,r.jsx)(e.li,{children:\"Open (A\\xE7\\u0131k): \\u0130kinci durumda Circuit Breaker a\\xE7\\u0131kt\\u0131r ve hizmet \\xE7a\\u011Fr\\u0131lar\\u0131 reddedilir. Bu durum, belirli bir s\\xFCre boyunca hizmet sa\\u011Flay\\u0131c\\u0131s\\u0131na yap\\u0131lan \\xE7a\\u011Fr\\u0131lar\\u0131n belirli bir oranda hata vermesi sonucu meydana gelir.\"}),`\n`,(0,r.jsx)(e.li,{children:\"Half-Open (Yar\\u0131 A\\xE7\\u0131k): \\xDC\\xE7\\xFCnc\\xFC durumda Circuit Breaker yar\\u0131 a\\xE7\\u0131kt\\u0131r ve birka\\xE7 hizmet \\xE7a\\u011Fr\\u0131s\\u0131n\\u0131 izin verir. Bu durumda, Circuit Breaker, bir hizmet \\xE7a\\u011Fr\\u0131s\\u0131 yaparak hizmet sa\\u011Flay\\u0131c\\u0131s\\u0131n\\u0131n tekrar \\xE7al\\u0131\\u015F\\u0131p \\xE7al\\u0131\\u015Fmad\\u0131\\u011F\\u0131n\\u0131 kontrol eder. E\\u011Fer hizmet \\xE7a\\u011Fr\\u0131s\\u0131 ba\\u015Far\\u0131l\\u0131 olursa, Circuit Breaker tekrar kapal\\u0131 duruma ge\\xE7er ve normal hizmet \\xE7a\\u011Fr\\u0131lar\\u0131na izin verir. Ancak, hizmet \\xE7a\\u011Fr\\u0131s\\u0131 ba\\u015Far\\u0131s\\u0131z olursa, Circuit Breaker tekrar a\\xE7\\u0131k duruma ge\\xE7er ve hizmet \\xE7a\\u011Fr\\u0131lar\\u0131 reddedilir.\"}),`\n`]}),`\n`,(0,r.jsx)(e.h2,{children:(0,r.jsx)(e.em,{children:\"Saga Pattern\"})}),`\n`,(0,r.jsx)(e.p,{children:\"Bu pattern, bir i\\u015Flem zinciri boyunca birden fazla mikroservis \\xE7a\\u011Fr\\u0131s\\u0131n\\u0131 y\\xF6netmek i\\xE7in kullan\\u0131l\\u0131r. Saga, bir i\\u015Flemi birden fazla ad\\u0131mda ger\\xE7ekle\\u015Ftiren bir i\\u015Flem zinciri olarak d\\xFC\\u015F\\xFCn\\xFClebilir. Her ad\\u0131m, bir mikroservis \\xE7a\\u011Fr\\u0131s\\u0131n\\u0131 temsil eder ve hata tolerans\\u0131n\\u0131 sa\\u011Flamak i\\xE7in geri alma (compensation) ad\\u0131mlar\\u0131 eklenir. \\xD6rne\\u011Fin, bir sipari\\u015Fin i\\u015Flenmesi, bir m\\xFC\\u015Fteriye \\xF6deme yap\\u0131lmas\\u0131 ve bir \\xFCr\\xFCn\\xFCn sevkiyat\\u0131n\\u0131n yap\\u0131lmas\\u0131 gibi bir\\xE7ok ad\\u0131mdan olu\\u015Fabilir.\"}),`\n`,(0,r.jsx)(e.h2,{children:(0,r.jsx)(e.em,{children:\"Event Sourcing Pattern\"})}),`\n`,(0,r.jsx)(e.p,{children:\"Bu pattern, bir uygulamada meydana gelen t\\xFCm olaylar\\u0131n bir kay\\u0131d\\u0131nda sakland\\u0131\\u011F\\u0131 bir yakla\\u015F\\u0131md\\u0131r. Bu olaylar, uygulaman\\u0131n durumunu olu\\u015Fturur ve her bir olay, uygulaman\\u0131n ge\\xE7mi\\u015F durumuna dayal\\u0131 olarak bir sonraki durumu etkiler. Bu pattern, bir\\xE7ok i\\u015Flemi ve veri g\\xFCncellemesini kolayla\\u015Ft\\u0131r\\u0131r ve hata ay\\u0131klama ve geri alma i\\u015Flemlerini kolayla\\u015Ft\\u0131r\\u0131r. \\xD6rne\\u011Fin, bir banka uygulamas\\u0131nda, bir m\\xFC\\u015Fterinin hesap hareketleri kaydedilebilir ve bu bilgiler, m\\xFC\\u015Fterinin hesap ge\\xE7mi\\u015Fi veya raporlama i\\xE7in kullan\\u0131labilir.\"}),`\n`,(0,r.jsx)(e.h2,{children:(0,r.jsx)(e.em,{children:\"Strangler Pattern\"})}),`\n`,(0,r.jsx)(e.p,{children:\"Bu desen, mevcut bir uygulaman\\u0131n veya sistemin s\\xFCrd\\xFCr\\xFClmesi veya yeniden geli\\u015Ftirilmesi gerekti\\u011Finde kullan\\u0131l\\u0131r. Temel amac\\u0131, mevcut sistemi yava\\u015F yava\\u015F terk ederek, yeni bir sistem veya uygulama in\\u015Fa etmeyi ve eski sistem yerine kullanmay\\u0131 hedefler.\"}),`\n`,(0,r.jsx)(e.h2,{children:(0,r.jsx)(e.em,{children:\"CQRS\"})}),`\n`,(0,r.jsx)(e.p,{children:\"Command Query Responsibility Segregation bir yaz\\u0131l\\u0131m mimarisi desenidir. Bu desen, bir uygulaman\\u0131n komutlar\\u0131n\\u0131 (veri yazma i\\u015Flemleri) ve sorgular\\u0131n\\u0131 (veri okuma i\\u015Flemleri) farkl\\u0131 i\\u015Flemler olarak ele alarak, farkl\\u0131 birimlerde i\\u015Flemesi fikrine dayan\\u0131r.\"}),`\n`,(0,r.jsx)(e.p,{children:\"Geleneksel bir uygulama mimarisinde, hem veri yazma hem de veri okuma i\\u015Flemleri ayn\\u0131 veri modeli \\xFCzerinde ger\\xE7ekle\\u015Ftirilir. Bu, uygulaman\\u0131n performans\\u0131n\\u0131 olumsuz y\\xF6nde etkileyebilir ve karma\\u015F\\u0131k i\\u015F mant\\u0131\\u011F\\u0131n\\u0131 zorla\\u015Ft\\u0131rabilir.\"}),`\n`,(0,r.jsx)(e.p,{children:\"CQRS yakla\\u015F\\u0131m\\u0131nda, veri yazma i\\u015Flemleri ve veri okuma i\\u015Flemleri farkl\\u0131 birimlerde ele al\\u0131n\\u0131r. Veri yazma i\\u015Flemleri, veri modelinde de\\u011Fi\\u015Fiklik yapmak yerine, komutlar arac\\u0131l\\u0131\\u011F\\u0131yla bir durum de\\u011Fi\\u015Fikli\\u011Fi ger\\xE7ekle\\u015Ftirir. Veri okuma i\\u015Flemleri ise, okuma i\\u015Flemleri i\\xE7in optimize edilmi\\u015F ayr\\u0131 bir veri modeli kullan\\u0131r. Bu, uygulaman\\u0131n performans\\u0131n\\u0131 art\\u0131rabilir ve daha kolay bak\\u0131m yap\\u0131labilmesini sa\\u011Flayabilir.\"})]})}function B(i={}){let{wrapper:e}=i.components||{};return e?(0,r.jsx)(e,Object.assign({},i,{children:(0,r.jsx)(u,i)})):u(i)}var C=B;return z(f);})();\n;return Component;"},"_id":"microservice-patterns-1.mdx","_raw":{"sourceFilePath":"microservice-patterns-1.mdx","sourceFileName":"microservice-patterns-1.mdx","sourceFileDir":".","contentType":"mdx","flattenedPath":"microservice-patterns-1"},"type":"Post","url":"/posts/microservice-patterns-1"}},"__N_SSG":true}