{"pageProps":{"post":{"title":"Compherensions vs Map, Filter vs Loops","date":"2022-12-01","contentType":"post","summary":"Performance comparision of three different approaches - list comprehensions, map filters, and for-loops - in manipulating lists in Python based on their execution time and memory usage.","body":{"raw":"\n# Compherensions vs Map, Filter vs Loops\n\n\n### Introduction\nIn this blog post, I will share the results of a simple experiment I did to compare the performance of three different approaches to manipulate lists in Python: list comprehensions, map and filter functions, and for loops. I used the `time` and `memory_profile` modules to measure the execution time and memory increments of each approach on a list.\n\n### Method\nAll inputs and outputs are the same for each mission and all methods. A function is written for each method accepts an array and returns an array.\n```\ndef my_function(arr: list):\n  # manipulate the array and save to the new_array\n  return new_array\n```\nI added `@profile` annotation to measure memory increments and used `time` to measure execution time.\n```\nimport time\nfrom memory_profiler import profile\n\n@profile\ndef my_function(arr:list):\n  pass\n\nstart_time = time.time()\nmy_function()\nend_time = time.time()\n```\n\n#### Mission 1 - Square Of All Items\nAn array is created with a same number like `[5,5,5,5...]`. Squares of the items are calculated with compherension, map and loop below.\n```\n# COMPEHERENSION solution\narr2 = [e**2 for e in arr]\n\n# MAP solution\narr2 = list(map(lambda x:x**2, arr))\n\n# LOOP solution\narr2 = []\nfor e in arr:\n  arr2.append(e**2)\n```\n\n\n{props.rdrTbl(\n  ['Method', 'Time Ratio', 'Memory Ratio'],\n  [\n    ['Compherension', '9.15885066986084', '7.7'],\n    ['Map', '18.482120275497437', '7.7'],\n    ['Loop', '18.548646688461304', '7.7'],\n  ],\n  ''\n)}\n\n\n\n- List comprehensions are the fastest way to manipulate lists in Python. They are concise, readable, and efficient.\n- Map and filter functions are slightly slower than list comprehensions, but still faster than for loops. They are useful when you need to apply a function to each element of a list or filter out some elements based on a condition.\n- For loops are the slowest way to manipulate lists in Python. They are more verbose and less expressive than the other approaches. They should be avoided when possible, unless you need to perform some complex logic that cannot be done with list comprehensions or map and filter functions.\n\nI hope this blog post was informative and helpful. You can find the code and the full results of the experiment on my GitHub repository: https://github.com/user/list-manipulation-python","code":"var Component=(()=>{var m=Object.create;var i=Object.defineProperty;var d=Object.getOwnPropertyDescriptor;var p=Object.getOwnPropertyNames;var u=Object.getPrototypeOf,f=Object.prototype.hasOwnProperty;var y=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),b=(t,e)=>{for(var o in e)i(t,o,{get:e[o],enumerable:!0})},s=(t,e,o,a)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let r of p(e))!f.call(t,r)&&r!==o&&i(t,r,{get:()=>e[r],enumerable:!(a=d(e,r))||a.enumerable});return t};var x=(t,e,o)=>(o=t!=null?m(u(t)):{},s(e||!t||!t.__esModule?i(o,\"default\",{value:t,enumerable:!0}):o,t)),w=t=>s(i({},\"__esModule\",{value:!0}),t);var h=y((P,l)=>{l.exports=_jsx_runtime});var v={};b(v,{default:()=>g,frontmatter:()=>_});var n=x(h()),_={title:\"Compherensions vs Map, Filter vs Loops\",date:new Date(16698528e5),contentType:\"post\",summary:\"Performance comparision of three different approaches - list comprehensions, map filters, and for-loops - in manipulating lists in Python based on their execution time and memory usage.\"};function c(t){let e=Object.assign({h1:\"h1\",h3:\"h3\",p:\"p\",code:\"code\",pre:\"pre\",h4:\"h4\",ul:\"ul\",li:\"li\"},t.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.h1,{children:\"Compherensions vs Map, Filter vs Loops\"}),`\n`,(0,n.jsx)(e.h3,{children:\"Introduction\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"In this blog post, I will share the results of a simple experiment I did to compare the performance of three different approaches to manipulate lists in Python: list comprehensions, map and filter functions, and for loops. I used the \",(0,n.jsx)(e.code,{children:\"time\"}),\" and \",(0,n.jsx)(e.code,{children:\"memory_profile\"}),\" modules to measure the execution time and memory increments of each approach on a list.\"]}),`\n`,(0,n.jsx)(e.h3,{children:\"Method\"}),`\n`,(0,n.jsx)(e.p,{children:\"All inputs and outputs are the same for each mission and all methods. A function is written for each method accepts an array and returns an array.\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{children:`def my_function(arr: list):\n  # manipulate the array and save to the new_array\n  return new_array\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"I added \",(0,n.jsx)(e.code,{children:\"@profile\"}),\" annotation to measure memory increments and used \",(0,n.jsx)(e.code,{children:\"time\"}),\" to measure execution time.\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{children:`import time\nfrom memory_profiler import profile\n\n@profile\ndef my_function(arr:list):\n  pass\n\nstart_time = time.time()\nmy_function()\nend_time = time.time()\n`})}),`\n`,(0,n.jsx)(e.h4,{children:\"Mission 1 - Square Of All Items\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"An array is created with a same number like \",(0,n.jsx)(e.code,{children:\"[5,5,5,5...]\"}),\". Squares of the items are calculated with compherension, map and loop below.\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{children:`# COMPEHERENSION solution\narr2 = [e**2 for e in arr]\n\n# MAP solution\narr2 = list(map(lambda x:x**2, arr))\n\n# LOOP solution\narr2 = []\nfor e in arr:\n  arr2.append(e**2)\n`})}),`\n`,t.rdrTbl([\"Method\",\"Time Ratio\",\"Memory Ratio\"],[[\"Compherension\",\"9.15885066986084\",\"7.7\"],[\"Map\",\"18.482120275497437\",\"7.7\"],[\"Loop\",\"18.548646688461304\",\"7.7\"]],\"\"),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"List comprehensions are the fastest way to manipulate lists in Python. They are concise, readable, and efficient.\"}),`\n`,(0,n.jsx)(e.li,{children:\"Map and filter functions are slightly slower than list comprehensions, but still faster than for loops. They are useful when you need to apply a function to each element of a list or filter out some elements based on a condition.\"}),`\n`,(0,n.jsx)(e.li,{children:\"For loops are the slowest way to manipulate lists in Python. They are more verbose and less expressive than the other approaches. They should be avoided when possible, unless you need to perform some complex logic that cannot be done with list comprehensions or map and filter functions.\"}),`\n`]}),`\n`,(0,n.jsx)(e.p,{children:\"I hope this blog post was informative and helpful. You can find the code and the full results of the experiment on my GitHub repository: https://github.com/user/list-manipulation-python\"})]})}function M(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(c,t)})):c(t)}var g=M;return w(v);})();\n;return Component;"},"_id":"blog/compherension-vs-map-filter-vs-loop.mdx","_raw":{"sourceFilePath":"blog/compherension-vs-map-filter-vs-loop.mdx","sourceFileName":"compherension-vs-map-filter-vs-loop.mdx","sourceFileDir":"blog","contentType":"mdx","flattenedPath":"blog/compherension-vs-map-filter-vs-loop"},"type":"Blog","url":"/blog/compherension-vs-map-filter-vs-loop"}},"__N_SSG":true}